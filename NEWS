* Status as of 2/22/99

Version 0.6.0 Released

*** Important Changes in 0.6.0 from 0.5.0 which may affect code ***

- All memory allocated which is received from libIDL must be freed
with glib free routines, i.e. g_free.  For instance the value from
IDL_ns_ident_to_qstring should be freed with g_free.

- IDL_tree_func now passes an IDL_tree_func_data struct pointer
instead of the just the tree node. This gives you the current node,
the up path of the traversal, and the real up path (from the node's up
pointer), which is useful since the paths can be different in the case
of a predefined identifier referenced in a different place. Be sure to
update your callbacks for 0.6.

- Do not rely on IDLN_* enumeration ordering.  An alternative method
for using jumptables is mentioned in the IDL header file.

** New Features for libIDL 0.6.0

- Overhauled versioning system, with support for libIDL-config, an
AM_PATH_LIBIDL Automake macro, and C version defines.

- New functions, including node properties and namespace functions.
IDL_parse_filename_with_input was added to facilitate porting to
platforms which don't have a readily available CPP (e.g. Win32).

- XPIDL support is now in place (optionally activated with a parse
flag).

- Additional support for node suppression with #pragma inhibit.

- Support for Win32.

- Many bug fixes.


* Status as of 8/17/98

** Just about everything is working now, except for a few small
ambiguity cases which may not get detected, but should be easily
avoidable anyway.  The changeover to using glib is there, and hash
tables are used extensively now so that the O order has been reduced.

Repository IDs are also generate properly now, along with the three
pragams, and there is also a declaration spec which can tag certain
interfaces to not generate tree data.  Error messages have also been
improved significantly.

The docs are out of date and need revamping.


* Status as of 7/18/98

** Most needed features are working to read CORBA v2.2 IDL.  See the
file BUGS to see what else needs to be done; at this point things like
speed are low priority, however a changeover to using glib and more
efficient data structures like sorted heaps or hashes might be in
order down the line.  I'm not sure how useful libIDL might be apart
from its use in an IDL compiler, but the docs still need work.

Andrew Veliath